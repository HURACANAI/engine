"""
Standalone Demo: Dual-Mode Trading System

This demonstrates the dual-mode system in isolation without requiring
the full Engine pipeline. Great for testing and understanding the system.
"""

import sys
import traceback
from datetime import datetime, timedelta, timezone

from src.cloud.training.models.asset_profiles import TradingMode
from src.cloud.training.models.dual_mode_coordinator import create_dual_mode_system
from src.cloud.training.models.mode_policies import SignalContext


def print_header(text: str):
    """Print formatted header."""
    print("\n" + "=" * 70)
    print(f"  {text}")
    print("=" * 70)


def print_section(text: str):
    """Print formatted section."""
    print(f"\n--- {text} ---")


def demo_dual_mode_system():
    """Demonstrate the dual-mode trading system."""

    try:
        print_header("DUAL-MODE TRADING SYSTEM DEMO")


            # Create the dual-mode system
            print("\n1. Creating dual-mode system...")
        coordinator, profile_manager, book_manager = create_dual_mode_system(
            total_capital_gbp=10000.0
        )
        print("‚úÖ System created successfully")

        # Show asset profiles
        print_section("Asset Profiles")
        for symbol in ["ETH", "SOL", "BTC", "DOGE"]:
            profile = profile_manager.get_profile(symbol)
            print(f"  {symbol}: {profile.mode.value}")
            if profile.long_hold:
                print(f"    - Long: max {profile.long_hold.max_book_pct*100:.0f}%, "
                      f"{len(profile.long_hold.add_grid_bps)} adds, "
                      f"{profile.long_hold.trail_style.value}")

        # Scenario 1: ETH Scalp Entry
        print_header("SCENARIO 1: ETH Scalp Entry (Short-Hold)")

        eth_scalp_context = SignalContext(
            symbol="ETH",
            current_price=2000.0,
            features={
                "micro_score": 65.0,
                "ignition_score": 50.0,
                "trend_strength": 0.4,
            },
            regime="trend",
            confidence=0.65,
            eps_net=0.001,
            volatility_bps=80.0,
            spread_bps=8.0,
            htf_bias=0.3,
            timestamp=datetime.now(),
        )

        signal = coordinator.evaluate_signal(eth_scalp_context)

        print(f"\nSignal Evaluation:")
        print(f"  Short-hold OK: {signal.short_ok} ({signal.short_reason})")
        print(f"  Long-hold OK: {signal.long_ok} ({signal.long_reason})")
        print(f"  Routed to: {signal.route_to.value if signal.route_to else 'None'}")

        if signal.route_to == TradingMode.SHORT_HOLD:
            # Open short-hold position
            book_manager.open_position(
                symbol="ETH",
                mode=TradingMode.SHORT_HOLD,
                entry_price=2000.0,
                size_gbp=200.0,
                stop_loss_bps=-10.0,
                take_profit_bps=15.0,
                entry_regime="trend",
                entry_confidence=0.65,
            )
            print("\n‚úÖ Opened short-hold scalp position")

        # Scenario 2: ETH Swing Entry
        print_header("SCENARIO 2: ETH Swing Entry (Long-Hold)")

        eth_swing_context = SignalContext(
            symbol="ETH",
            current_price=2000.0,
            features={
                "micro_score": 60.0,
                "ignition_score": 75.0,
                "trend_strength": 0.75,
            },
            regime="trend",
            confidence=0.75,
            eps_net=0.002,
            volatility_bps=80.0,
            spread_bps=8.0,
            htf_bias=0.7,
            timestamp=datetime.now(),
        )

        signal = coordinator.evaluate_signal(eth_swing_context)

        print(f"\nSignal Evaluation:")
        print(f"  Short-hold OK: {signal.short_ok} ({signal.short_reason})")
        print(f"  Long-hold OK: {signal.long_ok} ({signal.long_reason})")
        print(f"  Routed to: {signal.route_to.value if signal.route_to else 'None'}")

        if signal.route_to == TradingMode.LONG_HOLD or signal.long_ok:
            # Open long-hold position
            book_manager.open_position(
                symbol="ETH",
                mode=TradingMode.LONG_HOLD,
                entry_price=2000.0,
                size_gbp=1000.0,
                stop_loss_bps=-150.0,
                entry_regime="trend",
                entry_confidence=0.75,
            )
            print("\n‚úÖ Opened long-hold swing position")

        # Scenario 3: Concurrent Positions
        print_header("SCENARIO 3: Concurrent Positions on ETH")

        exposure = book_manager.get_exposure("ETH")
        print(f"\nETH Exposure:")
        print(f"  Short-hold: ¬£{exposure['short_gbp']:.2f}")
        print(f"  Long-hold: ¬£{exposure['long_gbp']:.2f}")
        print(f"  Total: ¬£{exposure['total_gbp']:.2f}")

        # Check conflict resolution
        resolution = coordinator.resolve_conflict("ETH")
        print(f"\nConflict Resolution:")
        print(f"  Can add short: {resolution.can_add_short}")
        print(f"  Can add long: {resolution.can_add_long}")
        print(f"  Max total: ¬£{resolution.max_total_exposure_gbp:.2f}")

        # Scenario 4: Price Move - Scalp Hits TP
        print_header("SCENARIO 4: Price Rally - Scalp Hits TP")

        # Update price to +15 bps (TP for scalp)
        new_price = 2030.0  # +1.5% = +150 bps
        book_manager.update_position_price("ETH", TradingMode.SHORT_HOLD, new_price)
        book_manager.update_position_price("ETH", TradingMode.LONG_HOLD, new_price)

        short_pos = book_manager.get_position("ETH", TradingMode.SHORT_HOLD)
        long_pos = book_manager.get_position("ETH", TradingMode.LONG_HOLD)

        print(f"\nPrice moved to ${new_price:.2f}")
        if short_pos:
            print(f"  Short-hold P&L: {short_pos.unrealized_pnl_bps:.1f} bps (¬£{short_pos.unrealized_pnl_gbp:.2f})")
        if long_pos:
            print(f"  Long-hold P&L: {long_pos.unrealized_pnl_bps:.1f} bps (¬£{long_pos.unrealized_pnl_gbp:.2f})")

        # Close scalp position (TP hit)
        if short_pos and short_pos.unrealized_pnl_bps >= 15.0:
            _, pnl = book_manager.close_position("ETH", TradingMode.SHORT_HOLD, new_price)
            print(f"\n‚úÖ Closed scalp position: ¬£{pnl:.2f} profit")

        # Scenario 5: Price Dip - Add to Swing
        print_header("SCENARIO 5: Price Dip - Add to Swing Position")

        # Price dips -150 bps (first add level)
        dip_price = 1970.0  # -1.5%
        book_manager.update_position_price("ETH", TradingMode.LONG_HOLD, dip_price)

        long_pos = book_manager.get_position("ETH", TradingMode.LONG_HOLD)
        if long_pos:
            print(f"\nPrice dipped to ${dip_price:.2f}")
            print(f"  Long-hold P&L: {long_pos.unrealized_pnl_bps:.1f} bps")

            # Check if should add
            dip_context = SignalContext(
                symbol="ETH",
                current_price=dip_price,
                features={},
                regime="trend",
                confidence=0.70,
                eps_net=0.001,
                volatility_bps=80.0,
                spread_bps=8.0,
                htf_bias=0.6,
                timestamp=datetime.now() + timedelta(hours=3),
            )

            should_add, reason, add_price = coordinator.should_add_to_position("ETH", dip_context)

            if should_add:
                book_manager.add_to_position("ETH", TradingMode.LONG_HOLD, dip_price, 500.0)
                print(f"\n‚úÖ Added to swing position: ¬£500")
            else:
                print(f"\n‚ö†Ô∏è  No add: {reason}")

        # Scenario 6: Price Recovers - Scale Out
        print_header("SCENARIO 6: Price Recovers - Scale Out of Swing")

        # Price recovers to +200 bps
        recovery_price = 2100.0
        book_manager.update_position_price("ETH", TradingMode.LONG_HOLD, recovery_price)

        long_pos = book_manager.get_position("ETH", TradingMode.LONG_HOLD)
        if long_pos:
            print(f"\nPrice recovered to ${recovery_price:.2f}")
            print(f"  Long-hold P&L: {long_pos.unrealized_pnl_bps:.1f} bps (¬£{long_pos.unrealized_pnl_gbp:.2f})")

            # Check if should scale out
            recovery_context = SignalContext(
                symbol="ETH",
                current_price=recovery_price,
                features={},
                regime="trend",
                confidence=0.70,
                eps_net=0.001,
                volatility_bps=80.0,
                spread_bps=8.0,
                htf_bias=0.6,
                timestamp=datetime.now() + timedelta(hours=12),
            )

            should_scale, reason, scale_pct = coordinator.should_scale_out_position("ETH", recovery_context)

            if should_scale and scale_pct:
                _, pnl = book_manager.scale_out_position("ETH", TradingMode.LONG_HOLD, recovery_price, scale_pct)
                print(f"\n‚úÖ Scaled out {scale_pct*100:.0f}%: ¬£{pnl:.2f} profit")
                print(f"   Remaining position: ¬£{long_pos.position_size_gbp:.2f}")

        # Final Statistics
        print_header("FINAL STATISTICS")

        stats = book_manager.get_combined_stats()

        print("\nShort-Hold Book:")
        print(f"  Positions: {stats['short_hold']['num_positions']}")
        print(f"  Trades: {stats['short_hold']['num_trades']}")
        print(f"  Win Rate: {stats['short_hold']['win_rate']:.1%}")
        print(f"  P&L: ¬£{stats['short_hold']['realized_pnl_gbp']:.2f}")

        print("\nLong-Hold Book:")
        print(f"  Positions: {stats['long_hold']['num_positions']}")
        print(f"  Trades: {stats['long_hold']['num_trades']}")
        print(f"  Win Rate: {stats['long_hold']['win_rate']:.1%}")
        print(f"  Realized P&L: ¬£{stats['long_hold']['realized_pnl_gbp']:.2f}")
        print(f"  Unrealized P&L: ¬£{stats['long_hold']['unrealized_pnl_gbp']:.2f}")

        print("\nTotal:")
        print(f"  Positions: {stats['total']['num_positions']}")
        print(f"  Exposure: ¬£{stats['total']['exposure_gbp']:.2f}")
        print(f"  Total P&L: ¬£{stats['total']['realized_pnl_gbp'] + stats['total']['unrealized_pnl_gbp']:.2f}")

        # Coordinator Stats
        coord_stats = coordinator.get_mode_stats()

        print("\nRouting Statistics:")
        print(f"  Total signals evaluated: {coord_stats['routing']['total_signals']}")
        print(f"  Routed to short-hold: {coord_stats['routing']['short_routed']}")
        print(f"  Routed to long-hold: {coord_stats['routing']['long_routed']}")

        print("\nSafety Rails:")
        print(f"  Total violations: {coord_stats['safety_rails']['total']}")

            print_header("DEMO COMPLETE")
            print("\n‚úÖ The dual-mode system successfully:")
            print("   1. Opened a short-hold scalp position")
            print("   2. Opened a long-hold swing position on same asset")
            print("   3. Closed the scalp at take-profit")
            print("   4. Added to the swing on a dip")
            print("   5. Scaled out of the swing in profit")
            print("\nüöÄ System is ready for production integration!")
            return True

    except Exception as e:
        print(f"\n‚ùå Demo failed with error: {e}")
        traceback.print_exc()
        return False


if __name__ == "__main__":
    success = demo_dual_mode_system()
    sys.exit(0 if success else 1)
